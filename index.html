<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>マイ・ゲメ</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #111;
      color: #fff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      overscroll-behavior: none;
    }
    .wrap {
      min-height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 10px;
      box-sizing: border-box;
    }
    .hud, .hint {
      width: 100%;
      max-width: 900px;
      margin: 0 auto;
      box-sizing: border-box;
    }
    .hud {
      display: flex;
      justify-content: space-between;
      opacity: .9;
      font-size: 16px;
    }

    /* ここが重要：aspect-ratio は使わない */
    canvas {
      display: block;
      width: 92vw;
      max-width: 900px;
      height: auto;              /* 800x600 に追従 */
      background: #0b0b0b;
      border: 1px solid #333;
      border-radius: 8px;
      touch-action: none;
    }

    .hint {
      opacity: .7;
      font-size: 14px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div id="scoreText">Score: 0</div>
      <div id="helpText">←→↑↓ / WASD / ドラッグ</div>
    </div>

    <!-- 座標系は固定（論理サイズ） -->
    <canvas id="game" width="800" height="600"></canvas>

    <div class="hint">Game Over時：<b>R</b> または <b>画面タップ</b> でリスタート</div>
  </div>

  <script>
    // =========================
    // 基本設定
    // =========================
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const scoreText = document.getElementById("scoreText");

    const GAME_W = 800;
    const GAME_H = 600;

    // DPR（スマホでぼやけ防止）
    // ※「論理座標は800x600のまま」にするのがコツ
    function applyDPR() {
      const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
      canvas.width  = Math.floor(GAME_W * dpr);
      canvas.height = Math.floor(GAME_H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 以降は800x600で描ける
    }
    applyDPR();
    window.addEventListener("resize", applyDPR);

    // =========================
    // 状態
    // =========================
    const playerSize = 40;
    const playerStart = { x: 60, y: 60 };

    const player = {
      x: playerStart.x,
      y: playerStart.y,
      size: playerSize,
      speed: 300, // px/sec
    };

    let enemies = [];
    let enemyVels = [];

    let score = 0;
    let gameOver = false;
    let lastTime = performance.now();

    // =========================
    // 入力（キーボード）
    // =========================
    const keys = {};
    window.addEventListener("keydown", (e) => {
      keys[e.key.toLowerCase()] = true;
      if (gameOver && e.key.toLowerCase() === "r") restartGame();
    });
    window.addEventListener("keyup", (e) => {
      keys[e.key.toLowerCase()] = false;
    });

    // =========================
    // 入力（タッチ/マウス：ドラッグで移動）
    // =========================
    let dragging = false;

    function canvasToWorld(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const x = (clientX - rect.left) * (GAME_W / rect.width);
      const y = (clientY - rect.top)  * (GAME_H / rect.height);
      return { x, y };
    }

    function clampPlayer() {
      player.x = Math.max(0, Math.min(GAME_W - player.size, player.x));
      player.y = Math.max(0, Math.min(GAME_H - player.size, player.y));
    }

    function movePlayerToPointer(clientX, clientY) {
      const p = canvasToWorld(clientX, clientY);
      player.x = p.x - player.size / 2;
      player.y = p.y - player.size / 2;
      clampPlayer();
    }

    canvas.addEventListener("pointerdown", (e) => {
      canvas.setPointerCapture(e.pointerId);

      // GameOverならタップで即リスタート
      if (gameOver) {
        restartGame();
        return;
      }

      dragging = true;
      movePlayerToPointer(e.clientX, e.clientY);
    });

    canvas.addEventListener("pointermove", (e) => {
      if (!dragging) return;
      movePlayerToPointer(e.clientX, e.clientY);
    });

    canvas.addEventListener("pointerup", () => {
      dragging = false;
    });

    // =========================
    // 敵生成
    // =========================
    function createEnemies() {
      enemies = [];
      enemyVels = [];

      for (let i = 0; i < 3; i++) {
        enemies.push({
          x: 100 + i * 220,
          y: 120 + i * 80,
          size: 40,
        });

        enemyVels.push({
          x: 150 + i * 60,
          y: 120 + i * 40,
        });
      }
    }

    function restartGame() {
      player.x = playerStart.x;
      player.y = playerStart.y;

      score = 0;
      gameOver = false;

      createEnemies();
      lastTime = performance.now();
      scoreText.textContent = "Score: 0";
    }

    // =========================
    // 更新
    // =========================
    function update(dt) {
      if (gameOver) return;

      // スコア：時間で増える（1秒=100点）
      score += dt * 100;
      scoreText.textContent = "Score: " + Math.floor(score);

      // プレイヤー移動
      const speed = player.speed;
      if (keys["arrowleft"] || keys["a"])  player.x -= speed * dt;
      if (keys["arrowright"] || keys["d"]) player.x += speed * dt;
      if (keys["arrowup"] || keys["w"])    player.y -= speed * dt;
      if (keys["arrowdown"] || keys["s"])  player.y += speed * dt;
      clampPlayer();

      // 敵移動
      enemies.forEach((e, i) => {
        e.x += enemyVels[i].x * dt;
        e.y += enemyVels[i].y * dt;

        // 反射
        if (e.x < 0) { e.x = 0; enemyVels[i].x *= -1; }
        if (e.x > GAME_W - e.size) { e.x = GAME_W - e.size; enemyVels[i].x *= -1; }

        if (e.y < 0) { e.y = 0; enemyVels[i].y *= -1; }
        if (e.y > GAME_H - e.size) { e.y = GAME_H - e.size; enemyVels[i].y *= -1; }
      });

      // 当たり判定
      for (const e of enemies) {
        const hit =
          player.x < e.x + e.size &&
          player.x + player.size > e.x &&
          player.y < e.y + e.size &&
          player.y + player.size > e.y;

        if (hit) {
          gameOver = true;
          break;
        }
      }
    }

    // =========================
    // 描画
    // =========================
    function draw() {
      ctx.clearRect(0, 0, GAME_W, GAME_H);

      // 背景
      ctx.fillStyle = "#0b0b0b";
      ctx.fillRect(0, 0, GAME_W, GAME_H);

      // プレイヤー
      ctx.fillStyle = "#ddd";
      ctx.fillRect(player.x, player.y, player.size, player.size);

      // 敵
      ctx.fillStyle = "#e11";
      enemies.forEach(e => {
        ctx.fillRect(e.x, e.y, e.size, e.size);
      });

      // GameOver表示
      if (gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.55)";
        ctx.fillRect(0, 0, GAME_W, GAME_H);

        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";

        ctx.font = "64px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("Game Over", GAME_W / 2, GAME_H / 2 - 20);

        ctx.font = "28px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
        ctx.fillText("Press R or Tap to Restart", GAME_W / 2, GAME_H / 2 + 40);

        ctx.textAlign = "left";
      }
    }

    // =========================
    // ループ
    // =========================
    function loop(now) {
      const dt = Math.min((now - lastTime) / 1000, 0.05);
      lastTime = now;

      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // 起動
    restartGame();
    requestAnimationFrame(loop);
  </script>
</body>
</html>
